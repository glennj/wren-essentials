// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"#module=time\n"
"class Delorian {\n"
"\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"#module=essentials\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((97..122).contains(x)) x = x - 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static downcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((65..90).contains(x)) x = x + 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"\n"
"    /* String matching with wildcards '*' and '?'\n"
"     * Algorithm from https://www.geeksforgeeks.org/wildcard-pattern-matching/\n"
"     */\n"
"    static strmatch(s, pattern) {\n"
"        // empty pattern can only match with empty string\n"
"        if (pattern.isEmpty) return s.isEmpty\n"
"\n"
"        // only non-empty pattern an empty string can match is \"*\"\n"
"        if (s.isEmpty) return pattern == \"*\"\n"
"\n"
"        var n = s.count\n"
"        var m = pattern.count\n"
"\n"
"        // lookup table for storing results of subproblems\n"
"        var lookup = (0..n).reduce([]) {|l, i| l + [[false] * (m+1)]}\n"
"\n"
"        // empty pattern can match with empty string\n"
"        lookup[0][0] = true\n"
"\n"
"        // Only '*' can match with empty string\n"
"        for (j in (1..m)) {\n"
"            if (pattern[j - 1] == \"*\") {\n"
"                lookup[0][j] = lookup[0][j - 1]\n"
"            }\n"
"        }\n"
"\n"
"        // fill the table in bottom-up fashion\n"
"        for (i in (1..n)) {\n"
"            for (j in (1..m)) {\n"
"\n"
"                // Two cases if we see a '*'\n"
"                // a) We ignore ‘*’ character and move to next character in the\n"
"                //    pattern, i.e., ‘*’ indicates an empty sequence.\n"
"                // b) '*' character matches with ith character in input\n"
"                if (pattern[j - 1] == \"*\") {\n"
"                    lookup[i][j] = lookup[i][j - 1] || lookup[i - 1][j]\n"
"\n"
"                // Current characters are considered as matching in two cases\n"
"                // a) current character of pattern is '?'\n"
"                // b) characters actually match\n"
"                } else if (pattern[j - 1] == \"?\" || s[i - 1] == pattern[j - 1]) {\n"
"                    lookup[i][j] = lookup[i - 1][j - 1]\n"
"\n"
"                // If characters don't match\n"
"                } else {\n"
"                    lookup[i][j] = false\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        return lookup[n][m]\n"
"    }\n"
"}\n"
"\n\n"
"#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* mirrorModuleSource =
"\n"
"// FIXME: Add cache.\n"
"\n"
"class Mirror {\n"
"  static reflect(reflectee) {\n"
"    var mirror = ObjectMirror\n"
"    if (reflectee is Class) mirror = ClassMirror\n"
"    if (reflectee is Fiber) mirror = FiberMirror\n"
"\n"
"    return mirror.new_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"class ObjectMirror is Mirror {\n"
"  foreign static canInvoke(reflectee, methodName)\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  classMirror {\n"
"    if (_classMirror == null) _classMirror = Mirror.reflect(_reflectee.type)\n"
"    return _classMirror\n"
"  }\n"
"\n"
"  moduleMirror { classMirror.moduleMirror }\n"
"\n"
"  reflectee { _reflectee }\n"
"\n"
"  canInvoke(signature) { classMirror.hasMethod(signature) }\n"
"}\n"
"\n"
"class ClassMirror is ObjectMirror {\n"
"  foreign static allAttributes(reflectee)\n"
"  foreign static hasMethod(reflectee, signature)\n"
"  foreign static methodNames(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"    _moduleMirror = null\n"
"\n"
"    _methods = ClassMirror.methodNames(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { _moduleMirror }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(reflectee)\n"
"    return attr != null ? attr.self : null\n"
"  }\n"
"\n"
"  hasMethod(signature) { ClassMirror.hasMethod(reflectee, signature) }\n"
"\n"
"  methodNames { _methodNames }\n"
"  methodMirrors { _methodMirrors }\n"
"}\n"
"\n"
"class FiberMirror is ObjectMirror {\n"
"  foreign static methodAt_(reflectee, stackTraceIndex)\n"
"  foreign static lineAt_(reflectee, stackTraceIndex)\n"
"  foreign static stackFramesCount_(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  lineAt(stackTraceIndex)   { FiberMirror.lineAt_(reflectee, stackTraceIndex) }\n"
"  methodAt(stackTraceIndex) { FiberMirror.methodAt_(reflectee, stackTraceIndex) }\n"
"  stackFramesCount          { FiberMirror.stackFramesCount_(reflectee) }\n"
"\n"
"  stackTrace {\n"
"    var reflectee = this.reflectee\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(reflectee)\n"
"    if (reflectee == Fiber.current) stackFramesCount = stackFramesCount - 1\n"
"    return StackTrace.new_(reflectee, stackFramesCount)\n"
"  }\n"
"}\n"
"\n"
"class MethodMirror is Mirror {\n"
"  foreign static module_(method)\n"
"  foreign static signature_(method)\n"
"\n"
"  construct new_(method/*, classMirror, signature*/) {\n"
"    _method = method\n"
"  }\n"
"\n"
"//  classMirror { Mirror.reflect(MethodMirror.class_(_method)) }\n"
"  moduleMirror { ModuleMirror.fromModule_(MethodMirror.module_(_method)) }\n"
"\n"
"//  arity { MethodMirror.arity_(_method) }\n"
"//  maxSlots { MethodMirror.maxSlots_(_method) }\n"
"//  numUpvalues { MethodMirror.maxSlots_(_numUpvalues) }\n"
"  signature { MethodMirror.signature_(_method) }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(_class)\n"
"    var methods = attr != null ? attr.methods : null\n"
"    return methods != null ? methods[signature] : null\n"
"  }\n"
"}\n"
"\n"
"class ModuleMirror is Mirror {\n"
"  foreign static fromName_(name)\n"
"  foreign static name_(reflectee)\n"
"\n"
"  static fromModule_(module) {\n"
"    return ModuleMirror.new_(module)\n"
"  }\n"
"\n"
"  static fromName(name) {\n"
"    var module = fromName_(name)\n"
"    if (null == module) Fiber.abort(\"Unkown module\")\n"
"\n"
"    return ModuleMirror.fromModule_(module)\n"
"  }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  name { ModuleMirror.name_(_reflectee) }\n"
"}\n"
"\n"
"class StackTrace {\n"
"  construct new_(fiber, stackFramesCount) {\n"
"    _fiber = fiber\n"
"    _stackTrace = []\n"
"    for (i in 0...stackFramesCount) {\n"
"      _stackTrace.add(StackTraceFrame.new_(fiber, i))\n"
"    }\n"
"  }\n"
"  \n"
"  static new(fiber) {\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(fiber)\n"
"\n"
"    return new_(fiber, stackFramesCount)\n"
"  }\n"
"\n"
"  frames { _stackTrace }\n"
"  toString { _stackTrace.join(\"\\n\") }\n"
"}\n"
"\n"
"class StackTraceFrame {\n"
"  construct new_(fiber, stackFramesIndex) {\n"
"    _line = FiberMirror.lineAt_(fiber, stackFramesIndex)\n"
"    _methodMirror = MethodMirror.new_(FiberMirror.methodAt_(fiber, stackFramesIndex))\n"
"  }\n"
"\n"
"  line { _line }\n"
"  methodMirror { _methodMirror }\n"
"\n"
"  // toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"  toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"}\n";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"#module=essentials\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((LOWERCASE_A..LOWERCASE_Z).contains(x)) x = x - 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static downcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((UPPERCASE_A..UPPERCASE_Z).contains(x)) x = x + 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static capitalize(s) {\n"
"        if (s.isEmpty) return \"\"\n"
"        if (s.count == 1) return Strings.upcase(s)\n"
"        return Strings.upcase(s[0]) + s[1..-1]\n"
"    }\n"
"    static titlecase(s) {\n"
"        return s.split(\" \").map {|w| capitalize(w) }.join(\" \")\n"
"    }\n"
"}\n"
"\n"
"var LOWERCASE_A = \"a\".bytes[0]\n"
"var LOWERCASE_Z = \"z\".bytes[0]\n"
"var UPPERCASE_A = \"A\".bytes[0]\n"
"var UPPERCASE_Z = \"Z\".bytes[0]\n"
"\n\n"
"#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"#module=time\n"
"class Delorian {\n"
"\n"
"}";

