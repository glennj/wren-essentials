// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"#module=time\n"
"class Delorian {\n"
"\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"#module=essentials\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((97..122).contains(x)) x = x - 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"\n"
"    static downcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((65..90).contains(x)) x = x + 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"\n"
"    /************************************************************************\n"
"     * String matching with wildcards '*' and '?'\n"
"     * Algorithm from https://www.geeksforgeeks.org/wildcard-pattern-matching/\n"
"     */\n"
"    static simpleMatch(s, pattern) {\n"
"        // empty pattern can only match with empty string\n"
"        if (pattern.isEmpty) return s.isEmpty\n"
"\n"
"        // only non-empty pattern an empty string can match is \"*\"\n"
"        if (s.isEmpty) return pattern == \"*\"\n"
"\n"
"        var n = s.count\n"
"        var m = pattern.count\n"
"\n"
"        // lookup table for storing results of subproblems\n"
"        var lookup = (0..n).reduce([]) {|l, i| l + [[false] * (m+1)]}\n"
"\n"
"        // empty pattern can match with empty string\n"
"        lookup[0][0] = true\n"
"\n"
"        // Only '*' can match with empty string\n"
"        for (j in (1..m)) {\n"
"            if (pattern[j - 1] == \"*\") {\n"
"                lookup[0][j] = lookup[0][j - 1]\n"
"            }\n"
"        }\n"
"\n"
"        // fill the table in bottom-up fashion\n"
"        for (i in (1..n)) {\n"
"            for (j in (1..m)) {\n"
"\n"
"                // Two cases if we see a '*'\n"
"                // a) We ignore ‘*’ character and move to next character in the\n"
"                //    pattern, i.e., ‘*’ indicates an empty sequence.\n"
"                // b) '*' character matches with ith character in input\n"
"                if (pattern[j - 1] == \"*\") {\n"
"                    lookup[i][j] = lookup[i][j - 1] || lookup[i - 1][j]\n"
"\n"
"                // Current characters are considered as matching in two cases\n"
"                // a) current character of pattern is '?'\n"
"                // b) characters actually match\n"
"                } else if (pattern[j - 1] == \"?\" || s[i - 1] == pattern[j - 1]) {\n"
"                    lookup[i][j] = lookup[i - 1][j - 1]\n"
"\n"
"                // If characters don't match\n"
"                } else {\n"
"                    lookup[i][j] = false\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        return lookup[n][m]\n"
"    }\n"
"\n"
"    /************************************************************************\n"
"     * Adapting the C implementation of Tcl's `string match` command\n"
"     * https://github.com/tcltk/tcl/blob/core-8-6-11/generic/tclUtil.c#L2366\n"
"     *\n"
"     * Special characters that can appear in a pattern:\n"
"        *\n"
"            Matches any sequence of characters in string, including a null\n"
"            string.\n"
"        ?\n"
"            Matches any single character in string.\n"
"        [chars]\n"
"            Matches any character in the set given by chars. If a sequence\n"
"            of the form x-y appears in chars, then any character between x\n"
"            and y, inclusive, will match. Ranges can be forward ([a-z]) or\n"
"            backward ([z-a]).\n"
"        \x\n"
"            Matches the single character x. This provides a way of\n"
"            avoiding the special interpretation of the characters *?[]\ in\n"
"            pattern. In a wren string, the backslash itself must be escaped:\n"
"                Strings.globMatch(\"a*b\", \"a\\*b\")   // expect: true\n"
"     *\n"
"     */\n"
"    static globMatch(s, pattern) { globMatchRec_(s, 0, pattern, 0) }\n"
"\n"
"    static globMatchRec_(s, sidx, pattern, pidx) {\n"
"        var slen = s.bytes.count\n"
"        var plen = pattern.bytes.count\n"
"        var p\n"
"        var ch1\n"
"        var startChar\n"
"        var endChar\n"
"\n"
"        while (true) {\n"
"            /* if we're at then end of the pattern,\n"
"             * we must also be at the end of the string\n"
"             */\n"
"            if (pidx == plen) {\n"
"                return sidx == slen\n"
"            }\n"
"            /* if we're at the end of the string,\n"
"             * match succeeds if the rest of the pattern is \"*\"\n"
"             */\n"
"            if (sidx == slen) {\n"
"                while (pidx < plen) {\n"
"                    if (pattern[pidx] != \"*\") {\n"
"                        return false\n"
"                    }\n"
"                    pidx = pidx + 1\n"
"                }\n"
"                return true\n"
"            }\n"
"\n"
"            p = pattern[pidx]\n"
"\n"
"            // \"*\" matches any substring\n"
"            if (p == \"*\") {\n"
"                // skip all successive \"*\"s\n"
"                while (pidx < plen && pattern[pidx] == \"*\") {\n"
"                    pidx = pidx + 1\n"
"                }\n"
"                if (pidx == plen) {\n"
"                    return true\n"
"                }\n"
"                p = pattern[pidx]\n"
"                while (true) {\n"
"                    if ((p != \"[\") && (p != \"?\") && (p != \"\\\")) {\n"
"                        while ((sidx < slen) && (p != s[sidx])) {\n"
"                            sidx = sidx + 1\n"
"                        }\n"
"                    }\n"
"                    if (globMatchRec_(s, sidx, pattern, pidx)) {\n"
"                        return true\n"
"                    }\n"
"                    if (sidx == slen) {\n"
"                        return false\n"
"                    }\n"
"                    sidx = sidx + 1\n"
"                }\n"
"            }\n"
"\n"
"            // \"?\" matches any single character\n"
"            if (p == \"?\") {\n"
"                pidx = pidx + 1\n"
"                sidx = sidx + 1\n"
"                continue\n"
"            }\n"
"\n"
"            // \"[\" in the pattern is followed by a list of characters or a range\n"
"            if (p == \"[\") {\n"
"                pidx = pidx + 1\n"
"                ch1 = s[sidx].bytes[0]\n"
"                sidx = sidx + 1\n"
"                while (true) {\n"
"                    if (pidx == plen) {\n"
"                        // pattern ended before bracket expression was closed\n"
"                        return false\n"
"                    }\n"
"\n"
"                    // this construct handles escaped close brackets\n"
"                    if (pattern[pidx] == \"\\\") {\n"
"                        pidx = pidx + 1\n"
"                        if (pidx == plen) {\n"
"                            return false\n"
"                        }\n"
"                    } else if (pattern[pidx] == \"]\") {\n"
"                        return false\n"
"                    }\n"
"\n"
"                    startChar = pattern[pidx].bytes[0]\n"
"                    pidx = pidx + 1\n"
"                    if (pidx < plen && pattern[pidx] == \"-\") {\n"
"                        pidx = pidx + 1\n"
"                        if (pidx == plen) {\n"
"                            // end of pattern in a range expression\n"
"                            return false\n"
"                        }\n"
"                        // handles escaped close brackets as range end char\n"
"                        if (pattern[pidx] == \"\\\") {\n"
"                            pidx = pidx + 1\n"
"                            if (pidx == plen) {\n"
"                                return false\n"
"                            }\n"
"                        } else if (pattern[pidx] == \"]\") {\n"
"                            // unended range\n"
"                            return false\n"
"                        }\n"
"\n"
"                        endChar = pattern[pidx].bytes[0]\n"
"                        pidx = pidx + 1\n"
"                        // matching forward ranges [a-z] or backwards [z-a]\n"
"                        if ((startChar <= ch1 && ch1 <= endChar) ||\n"
"                                (endChar <= ch1 && ch1 <= startChar)) {\n"
"                            break\n"
"                        }\n"
"                    } else {\n"
"                        /* not in a range expression, test the string's ch1\n"
"                         * against this char in the bracket expr\n"
"                         */\n"
"                        if (startChar == ch1) {\n"
"                            break\n"
"                        }\n"
"                    }\n"
"                }\n"
"                if (pidx == plen) {\n"
"                    // matched the character, but the bracket expr is unclosed\n"
"                    return false\n"
"                }\n"
"                while (pattern[pidx] != \"]\") {\n"
"                    pidx = pidx + 1\n"
"                }\n"
"                pidx = pidx + 1\n"
"                continue\n"
"            }\n"
"\n"
"            /* if the next character is \"\\\", just remove it\n"
"             * so we do exact matching on the char that follows\n"
"             */\n"
"            if (p == \"\\\") {\n"
"                pidx = pidx + 1\n"
"                if (pidx == plen) {\n"
"                    return false\n"
"                }\n"
"            }\n"
"\n"
"            // there's no special character. Make sure these match\n"
"            if (s[sidx] != pattern[pidx]) {\n"
"                return false\n"
"            }\n"
"\n"
"            pidx = pidx + 1\n"
"            sidx = sidx + 1\n"
"        }\n"
"    }\n"
"}\n"
"\n\n"
"#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* mirrorModuleSource =
"\n"
"// FIXME: Add cache.\n"
"\n"
"class Mirror {\n"
"  static reflect(reflectee) {\n"
"    var mirror = ObjectMirror\n"
"    if (reflectee is Class) mirror = ClassMirror\n"
"    if (reflectee is Fiber) mirror = FiberMirror\n"
"\n"
"    return mirror.new_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"class ObjectMirror is Mirror {\n"
"  foreign static canInvoke(reflectee, methodName)\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  classMirror {\n"
"    if (_classMirror == null) _classMirror = Mirror.reflect(_reflectee.type)\n"
"    return _classMirror\n"
"  }\n"
"\n"
"  moduleMirror { classMirror.moduleMirror }\n"
"\n"
"  reflectee { _reflectee }\n"
"\n"
"  canInvoke(signature) { classMirror.hasMethod(signature) }\n"
"}\n"
"\n"
"class ClassMirror is ObjectMirror {\n"
"  foreign static allAttributes(reflectee)\n"
"  foreign static hasMethod(reflectee, signature)\n"
"  foreign static methodNames(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"    _moduleMirror = null\n"
"\n"
"    _methods = ClassMirror.methodNames(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { _moduleMirror }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(reflectee)\n"
"    return attr != null ? attr.self : null\n"
"  }\n"
"\n"
"  hasMethod(signature) { ClassMirror.hasMethod(reflectee, signature) }\n"
"\n"
"  methodNames { _methodNames }\n"
"  methodMirrors { _methodMirrors }\n"
"}\n"
"\n"
"class FiberMirror is ObjectMirror {\n"
"  foreign static methodAt_(reflectee, stackTraceIndex)\n"
"  foreign static lineAt_(reflectee, stackTraceIndex)\n"
"  foreign static stackFramesCount_(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  lineAt(stackTraceIndex)   { FiberMirror.lineAt_(reflectee, stackTraceIndex) }\n"
"  methodAt(stackTraceIndex) { FiberMirror.methodAt_(reflectee, stackTraceIndex) }\n"
"  stackFramesCount          { FiberMirror.stackFramesCount_(reflectee) }\n"
"\n"
"  stackTrace {\n"
"    var reflectee = this.reflectee\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(reflectee)\n"
"    if (reflectee == Fiber.current) stackFramesCount = stackFramesCount - 1\n"
"    return StackTrace.new_(reflectee, stackFramesCount)\n"
"  }\n"
"}\n"
"\n"
"class MethodMirror is Mirror {\n"
"  foreign static module_(method)\n"
"  foreign static signature_(method)\n"
"\n"
"  construct new_(method/*, classMirror, signature*/) {\n"
"    _method = method\n"
"  }\n"
"\n"
"//  classMirror { Mirror.reflect(MethodMirror.class_(_method)) }\n"
"  moduleMirror { ModuleMirror.fromModule_(MethodMirror.module_(_method)) }\n"
"\n"
"//  arity { MethodMirror.arity_(_method) }\n"
"//  maxSlots { MethodMirror.maxSlots_(_method) }\n"
"//  numUpvalues { MethodMirror.maxSlots_(_numUpvalues) }\n"
"  signature { MethodMirror.signature_(_method) }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(_class)\n"
"    var methods = attr != null ? attr.methods : null\n"
"    return methods != null ? methods[signature] : null\n"
"  }\n"
"}\n"
"\n"
"class ModuleMirror is Mirror {\n"
"  foreign static fromName_(name)\n"
"  foreign static name_(reflectee)\n"
"\n"
"  static fromModule_(module) {\n"
"    return ModuleMirror.new_(module)\n"
"  }\n"
"\n"
"  static fromName(name) {\n"
"    var module = fromName_(name)\n"
"    if (null == module) Fiber.abort(\"Unkown module\")\n"
"\n"
"    return ModuleMirror.fromModule_(module)\n"
"  }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  name { ModuleMirror.name_(_reflectee) }\n"
"}\n"
"\n"
"class StackTrace {\n"
"  construct new_(fiber, stackFramesCount) {\n"
"    _fiber = fiber\n"
"    _stackTrace = []\n"
"    for (i in 0...stackFramesCount) {\n"
"      _stackTrace.add(StackTraceFrame.new_(fiber, i))\n"
"    }\n"
"  }\n"
"  \n"
"  static new(fiber) {\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(fiber)\n"
"\n"
"    return new_(fiber, stackFramesCount)\n"
"  }\n"
"\n"
"  frames { _stackTrace }\n"
"  toString { _stackTrace.join(\"\\n\") }\n"
"}\n"
"\n"
"class StackTraceFrame {\n"
"  construct new_(fiber, stackFramesIndex) {\n"
"    _line = FiberMirror.lineAt_(fiber, stackFramesIndex)\n"
"    _methodMirror = MethodMirror.new_(FiberMirror.methodAt_(fiber, stackFramesIndex))\n"
"  }\n"
"\n"
"  line { _line }\n"
"  methodMirror { _methodMirror }\n"
"\n"
"  // toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"  toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"}\n";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"#module=essentials\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((LOWERCASE_A..LOWERCASE_Z).contains(x)) x = x - 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static downcase(s) {\n"
"        return s.bytes.map { |x|\n"
"            if ((UPPERCASE_A..UPPERCASE_Z).contains(x)) x = x + 32\n"
"            return String.fromByte(x)\n"
"        }.join(\"\")\n"
"    }\n"
"    static capitalize(s) {\n"
"        if (s.isEmpty) return \"\"\n"
"        if (s.count == 1) return Strings.upcase(s)\n"
"        return Strings.upcase(s[0]) + s[1..-1]\n"
"    }\n"
"    static titlecase(s) {\n"
"        return s.split(\" \").map {|w| capitalize(w) }.join(\" \")\n"
"    }\n"
"}\n"
"\n"
"var LOWERCASE_A = \"a\".bytes[0]\n"
"var LOWERCASE_Z = \"z\".bytes[0]\n"
"var UPPERCASE_A = \"A\".bytes[0]\n"
"var UPPERCASE_Z = \"Z\".bytes[0]\n"
"\n\n"
"#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"#module=time\n"
"class Delorian {\n"
"\n"
"}";

